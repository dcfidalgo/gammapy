
# PIG 6 - CTA observation handling in Gammapy

* Author: David Fidalgo, Christoph Deil, RÃ©gis Terrier et al
* Created: October 10, 2018
* Accepted: --
* Status: Being discussed
* Discussion: --

## Abstract

In this PIG we want to outline an improvement of the CTA observation handling in Gammapy.
The current handling has some limitations and misses some key features, like selecting a given time interval and performing an analysis on it.
We also want to start relying more on GTIs instead  
Since specifics of the final data format of CTA are still unclear, this PIG does not aim for a final implementation of CTA observation handling, nor the handling of all types of data from various instruments forseen for Gammapy in the future.
It focuses on trying to resolve current limitations when analyzing IACT data.
This PIG emerged at the Coding Spring in Madrid 2018.

## Some terminology

This terminology and the definition of the terms will probably change or be expanded once the final data format of CTA is decided.
For now we will use following definitions to go forward in Gammapy:

* **GTI (good time interval)**:
  * time intervals for which the instrument was on
  * the sum over these time intervals equals the *on time*


* **Observation**:
  * has a unique identifier, the *obs_id*
  * contains 1 event list, 1 GTI table and 1 corresponding set of IRFs (aeff, edisp, psf)
  * has 1 dead-time fraction (`DEADC`)
  * the live time of the observation is obtained as `ONTIME * (1 - DEADC)`
 

* **Observation library**:
  * the repository where the observations and IRFs are stored
  * it has a manifest connecting all observation files and their IRFs

## 1. Background / What we have right now

In the current implementation we use the `DataStore` class to connect to an *observation library* that consists of two fits files, the *observation index table* and the *HDU index table* (see [this data storing scheme](https://gamma-astro-data-formats.readthedocs.io/en/latest/data_storage/index.html)).
The `DataStoreObservation` is a proxy object to the `DataStore` and points to a single *observation* in the *observation library*.
The `DataStoreObservation` never holds on to the observation data in memory and only reads it when explicitly accessed (`.events`, `.gti`, `.aeff`, etc.).
However, it does some caching of meta data.
Recently a new observation class `ObservationCTA` was added that is capable of storing all observation data in memory.
However, with the new scheme proposed further down, this class becomes superfluous and can again be removed.

Normally the user starts an analysis with the creation of a `DataStore` object from which she/he extracts an `ObservationList` providing *obs_ids*.
All analysis classes take as input an `ObservationList`, which is basically a python list of `DataStoreObservation`s.

### Limitations

* We can only analyze data for which its *observation library* has the [index table format](https://gamma-astro-data-formats.readthedocs.io/en/latest/data_storage/index.html).
* The current scheme does not allow for an analysis of a given time interval by the user.
Only full runs/observations can be processed.
* We do not support event selections before starting the analysis steps, such as event type selection, phase selection or time selection.
* It is cumbersome to write a copy of an observation (possibly modified) back to disk

## 2. Objectives

* We want to support more formats for the *observation library* (like ctools XML format), and make it easy to include future formats which are yet to be decided.
* Users should be able to run an analysis (1D and 3D) on a given time interval, independent of the time intervals of the single observations.
* We should support event selections before starting the analysis steps (selecting event type, event phase, ...) and possible allow for custom selections, e.g. `MC_ID` in the current CTA 1DC.

### Use cases

* Read in an observation from an *observation library* given in ctool's XML format
* Create an observation *from scratch* and write it to disk with an *observation library* of various formats.
* Do a 1D or 3D analysis for part of a run (say 1 minute)
* Do a 1D or 3D analysis for multiple runs (say 1 night or week)
* Make GPS survey maps for CTA (process 10 GB of events data and 3000 runs)

## 3. What others have

With *Fermi-LAT*, you always have `gtselect` and `gtmktime` at the start to [prepare your data](https://fermi.gsfc.nasa.gov/ssc/data/analysis/scitools/data_preparation.html).
Following analysis steps partly rely on "data sub space" DSS header keys for processing, which are stored in the output fits files of the `gtselect` and `gtmktime` step.

In *ctools*, every analysis starts with an "observation definition file" and also by [running `ctselect`](http://cta.irap.omp.eu/ctools/users/tutorials/1dc/first_select_obs.html)
(as far as i understand their code, for the time selection it only allows for selecting or skipping GTI intervals given with the event list)

## 4. Proposal

### General idea and class diagram
The general idea is to have an `Observations` class that is the starting point of all analyses and is passed on to the analysis classes of the 1D and 3D analysis (effectively it replaces the `ObservationList` class).
The user should only have to interact with this class, which makes it an **interface** to the other classes described in the following (`Observation` and `DataStore`), and therefore mainly consists of *convenient functions*.
The `Observations` class holds a list of `Observation` objects.

The `Observation` class is essentially a **proxy class** to the *data store* classes.
In addition an `Observation` object will also hold an `ObservationFilter` object, which is used to **orchestrate the filtering** of the data, mainly the event list.
The filtering is applied *on-the-fly* when accessing the observation data.
In this way we avoid storing the modified observation data in memory, which is important for the last use case specified above.

The different **data store** classes are:
* `DataStoreIndex`: This is basically just a renaming of the current `DataStore`
* `DataStoreXML`: This class is able to read XML files as used for *ctools* (maybe this class can be combined with the `DataStoreIndex`)
* `DataStoreInMemory`: This *data store* class is special in the sense that it does not point to files on disk, but holds the information data in memory. 
This can be useful when creating observations from *scratch*, by simulating the event list for example.

All *data store* classes inherit from a **parent** `DataStore` class that names the necessary methods, which have to be implemented by the Child classes.

The new scheme proposed is illustrated by the class diagram below.
The attributes and methods of the classes are not fully worked out and are merely suggestive.
Some more specifics of the classes and their methods are outlined [in this notebook](https://github.com/gammapy/gammapy-extra/blob/master/experiments/data.ipynb).

### Implementation road map

In a first step we want to focus on implementing the `Observations`, `Observation` and `ObservationFilter` classes.
They should be able to work together with the current `DataStore` class after some minor changes to it.
For the `Observation` class, the current `DataStoreObservation` can be a prototype.

In a second step we want to generalize the *data store* classes and implement the `DataStoreXML` and `DataStoreInMemory` classes.

### Proposed class diagram

![Proposed class diagram](https://github.com/dcfidalgo/gammapy/blob/pig-006/docs/development/pigs/pig6_class_diagram.png)
